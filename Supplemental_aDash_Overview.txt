;; This is supposed to be a LLM readable overview and examples of how adash.ahk works in general. 
;; These are all tests create to ensure all of the libraries functions are working properly. 
;; Review these functions and understand the adash library properly.
;; For more information on adash, check out https://github.com/adash-ahk/adash.ahk

_ := adash
assert := expect
assert.group(".chunk")
assert.label("default tests")
assert.test(_.chunk(["a", "b", "c", "d"], 2), [["a", "b"], ["c", "d"]])
assert.test(_.chunk(["a", "b", "c", "d"], 3), [["a", "b", "c"], ["d"]])
var := [1,2,3]
_.chunk(var, 2)
assert.label("parameter mutation")
assert.test(var, [1,2,3])
assert.label("string input")
assert.test(_.chunk("Neo"), [ [ 'N' ], [ 'e' ], [ 'o' ] ])
assert.group(".compact")
assert.label("default tests")
assert.test(_.compact([0, 1, false, 2, "", 3]), [1, 2, 3])
assert.test(_.compact([1, 2, 3, 4, 5, 6, "", "", ""]), [1, 2, 3, 4, 5, 6])
assert.label("empty and unset values")
assert.test(_.compact([1, 2, 3, 4, unset, unset, "", "", ""]), [1, 2, 3, 4])
assert.label("all empty and unset values")
assert.test(_.compact([unset, unset, , , "", "",]), [])
assert.group(".depthOf")
assert.label("default tests")
assert.test(_.depthOf([1]), 1)
assert.test(_.depthOf([1, [2]]), 2)
assert.test(_.depthOf([1, [[2]]]), 3)
assert.test(_.depthOf([1, [2, [3, [4]], 5]]), 4)
assert.group(".difference")
assert.label("default tests")
assert.test(_.difference([2, 1], [2, 3]), [1])
assert.test(_.difference([2, 1], [3]), [2, 1])
assert.test(_.difference(["Barney", "Neo"], ["Neo"]), ["Barney"])
assert.test(_.difference(["Barney", "Neo"], []), ["Barney", "Neo"])
assert.test(_.difference(["Barney", "Neo"], ["Pebbles"], ["Neo"]), ["Barney"])
assert.label("remove repeat values")
assert.test(_.difference([50, 50, 90], [50, 80]), [90])
assert.group(".drop")
assert.label("default tests")
assert.test(_.drop([1, 2, 3]), [2, 3])
assert.test(_.drop([1, 2, 3], 2), [3])
assert.test(_.drop([1, 2, 3], 5), [])
assert.test(_.drop([1, 2, 3], 0), [1, 2, 3])
assert.test(_.drop("neo"), ["e", "o"])
assert.test(_.drop(100), ["0", "0"])
assert.test(_.drop([]), [])
assert.group(".dropRight")
assert.label("default tests")
assert.test(_.dropRight([1, 2, 3]), [1, 2])
assert.test(_.dropRight([1, 2, 3], 2), [1])
assert.test(_.dropRight([1, 2, 3], 5), [])
assert.test(_.dropRight([1, 2, 3], 0), [1, 2, 3])
assert.test(_.dropRight("neo"), ["n", "e"])
assert.test(_.dropRight(100), ["1", "0"])
assert.test(_.dropRight([]), [])
assert.group(".fill")
assert.label("default tests")
arr := [1, 2, 3]
assert.test(_.fill(arr, "a"), ["a", "a", "a"])
assert.test(_.fill([4, 6, 8, 10], "*", 2, 4), [4, "*", "*", 10])
assert.test(arr, ["a", "a", "a"], "expected mutation did not occur")
assert.group(".flatten")
assert.label("default tests")
assert.test(_.flatten([1, [2, [3, [4]], 5]]), [1, 2, [3, [4]], 5])
assert.test(_.flatten([[1, 2, 3], [4, 5, 6]]), [1, 2, 3, 4, 5, 6])
apiResponse := [
	{id: 1, name: "Item 1", details: ["Detail 1", "Detail 2"]}
	, {id: 2, name: "Item 2", details: ["Detail 3", ["Sub-detail 1", "Sub-detail 2"]]}
	, {id: 3, name: "Item 3", details: ["Detail 4"]}]
flattenedDetails := _.flattenDeep(_.map(apiResponse, (item) => item.details))
assert.test(flattenedDetails, ["Detail 1", "Detail 2", "Detail 3", "Sub-detail 1", "Sub-detail 2", "Detail 4"])
assert.group(".flattenDeep")
assert.label("default tests")
assert.test(_.flattenDeep([1]), [1])
assert.test(_.flattenDeep([1, [2]]), [1, 2])
assert.test(_.flattenDeep([1, [2, [3, [4]], 5]]), [1, 2, 3, 4, 5])
assert.test(_.flattenDeep({key: 1}), [1])
assert.group(".flattenDepth")
assert.label("default tests")
assert.test(_.flattenDepth([1, [2, [3, [4]], 5]], 1), [1, 2, [3, [4]], 5])
assert.test(_.flattenDepth([1, [2, [3, [4]], 5]], 2), [1, 2, 3, [4], 5])
assert.group(".fromPairs")
assert.label("default tests")
assert.test(_.fromPairs([["a", 1], ["b", 2]]), {a: 1, b: 2})
assert.group(".head")
assert.label("default tests")
assert.test(_.head([1, 2, 3]), 1)
assert.test(_.head({a: 1, b: 2, c:3}), 1)
assert.test(_.head("Neo"), "N")
assert.test(_.head([]), "")
assert.test(_.head(100), "1")
assert.label("alias")
assert.test(_.first([1, 2, 3]), 1)
assert.test(_.first([]), "")
assert.test(_.first("Neo"), "N")
assert.test(_.first(100), "1")
assert.group(".indexOf")
assert.label("default tests")
assert.test(_.indexOf([1, 2, 1, 2], 2), 2)
assert.test(_.indexOf([1, 2, 1, 2], 2, 3), 4)
_.stringCaseSense := true
assert.test(_.indexOf(["neo", "morpheus"], "Neo"), -1)
_.stringCaseSense := false
assert.test(_.indexOf(["neo", "morpheus"], "trinity"), -1)
assert.label("object")
assert.test(_.indexOf({foo: 1, bar: 2}, 2), "bar")
assert.label("array of empty object")
assert.test(_.indexOf([{}], {}), 1)
assert.label("string input")
assert.test(_.indexOf("hello", "l"), 3)
assert.label("string input")
assert.test(_.indexOf("hello", "hello"), -1)
userData := [" John Doe, 30 ", "Jane Smith,  25", "ALICE OCONNOR,45"]
cleanedData := _.map(userData, myFunction)
myFunction(user) {
	name := adash.trim(adash.lowerFirst(_.join(adash.take(user, adash.indexOf(user, ",")), "")))
	age := 10
	return {name: name, age: age}
}
warnings := ["Intrusion detected", "System overload", "Intrusion detected", "Power failure"]
index := _.indexOf(warnings, "Intrusion detected", -2)
msgbox("The first warning from the offset is at position: " index)
assert.group(".initial")
assert.label("default tests")
assert.test(_.initial([1, 2, 3]), [1, 2])
assert.test(_.initial("neo"), ["n", "e"])
assert.test(_.initial(100), ["1", "0"])
assert.test(_.initial([]), [])
assert.group(".intersection")
assert.label("default tests")
assert.test(_.intersection([2, 1], [2, 3]), [2])
assert.label("many arrays")
assert.test(_.intersection([2, 1], [2, 3], [1, 2], [2]), [2])
assert.label("no intersecting values")
assert.test(_.intersection([1,2,3], [0], [1,2,3]), [])
assert.label("keyed object")
intersectionVar := {a: 1, b: 2}
assert.test(_.intersection([1,2,3], intersectionVar), [1,2])
assert.label("no mutation of input")
intersectionVar := [1,2,3]
assert.test(_.intersection(intersectionVar, [1]), [1])
assert.test(intersectionVar, [1,2,3])
assert.group(".join")
assert.label("default tests")
assert.test(_.join(["a", "b", "c"], "~"), "a~b~c")
assert.test(_.join(["a", "b", "c"]), "a,b,c")
assert.test(_.join({first: 1, second: 2, third: 3}), "1,2,3")
assert.test(_.join({first: 1, second: 2, third: 3}, "~"), "1~2~3")
assert.test(_.join("Neo"), "N,e,o")
assert.group(".last")
assert.label("default tests")
assert.test(_.last([1, 2, 3]), 3)
assert.test(_.last([]), "")
assert.test(_.last("neo"), "o")
assert.test(_.last(100), 0)
assert.label("no mutations")
arr := [1, 2, "hey"]
assert.test(_.last(arr), "hey")
assert.test(arr.length, 3)
assert.group(".lastIndexOf")
assert.label("default tests")
assert.test(_.lastIndexOf([1, 2, 1, 2], 2), 4)
assert.test(_.lastIndexOf([1, 2, 1, 2], 1, 3), 3)
_.stringCaseSense := true
assert.test(_.lastIndexOf(["neo", "morpheus"], "Neo"), -1)
_.stringCaseSense := false
assert.test(_.lastIndexOf([3, 4, 5, 6], 7), -1)
assert.test(_.lastIndexOf(["neo", "morpheus", "neo", "morpheus"], "morpheus"), 4)
assert.test(_.lastIndexOf(["neo", "morpheus", "neo", "morpheus"], "neo", 2), 3)
_.stringCaseSense := true
assert.test(_.lastIndexOf(["neo", "morpheus"], "Neo"), -1)
assert.test(_.lastIndexOf([1, "2", 3, 2], 2), 4)
assert.test(_.lastIndexOf([3, 3, 3, 3], 3, 2), 3)
assert.test(_.lastIndexOf([true, false, false, true], false), 3)
assert.test(_.lastIndexOf([true, false, false, true, true], true, 3), 4)
assert.test(_.lastIndexOf([], 1), -1)
assert.test(_.lastIndexOf("hello", "l"), 4)
assert.group(".nth")
assert.label("default tests")
assert.test(_.nth([1, 2, 3]), 1)
assert.test(_.nth([1, 2, 3], -3), 1)
assert.test(_.nth([1, 2, 3], 5), "")
assert.test(_.nth("neo"), "n")
assert.test(_.nth(100), "1")
assert.test(_.nth([1, 2, 3], 0), 1)
assert.test(_.nth([]), "")
assert.group(".reverse")
assert.label("default tests")
assert.test(_.reverse(["a", "b", "c"]), ["c", "b", "a"])
assert.test(_.reverse([{foo: "bar"}, "b", "c"]), ["c", "b", {foo: "bar"}])
assert.test(_.reverse([[1, 2, 3], "b", "c"]), ["c", "b", [1, 2, 3]])
reverseVar := [1,2,3]
assert.test(_.reverse(reverseVar), [3, 2, 1])
assert.test(reverseVar, [1,2,3])
assert.group(".slice")
assert.label("default tests")
assert.test(_.slice([1, 2, 3], 1, 2), [1, 2])
assert.test(_.slice([1, 2, 3], 1), [1, 2, 3])
assert.test(_.slice([1, 2, 3], 5), [])
assert.test(_.slice("neo"), ["n", "e", "o"])
assert.test(_.slice(100), ["1", "0", "0"])
assert.group(".sortedIndex")
assert.label("default tests")
assert.test(_.sortedIndex([30, 50], 40),2)
assert.test(_.sortedIndex([30, 50], 20),1)
assert.test(_.sortedIndex([30, 50], 99),3)
assert.group(".sortedUniq")
assert.label("default tests")
assert.test(_.sortedUniq([1, 1, 2]), [1, 2])
_.stringCaseSense := true
assert.test(_.sortedUniq(["Neo", "Barney", "morpheus", "morpheus"]), ["Neo", "Barney", "morpheus"])
_.stringCaseSense := false
arr := [1, 2, 3, 3, 4, 4, 5, 6, 7, 7, 7, 8, 8, 9, 10]
arr2 := _.sortedUniq(arr)
assert.test(arr.length, 15)
assert.test(arr2.length, 10)
assert.group(".tail")
assert.label("default tests")
assert.test(_.tail([1, 2, 3]), [2, 3])
assert.test(_.tail("neo"), ["e", "o"])
assert.test(_.tail(100), ["0", "0"])
assert.test(_.tail([]), [])
assert.test(_.tail([5]), [])
assert.group(".take")
assert.label("default tests")
assert.test(_.take([1, 2, 3]), [1])
assert.test(_.take([1, 2, 3], 2), [1, 2])
assert.test(_.take([1, 2, 3], 5), [1, 2, 3])
assert.test(_.take([1, 2, 3], 0), [])
assert.test(_.take("neo"), ["n"])
assert.test(_.take(100), ["1"])
assert.test(_.take([]), [])
user := "Mr Anderson, 30"
assert.test(_.take(user, _.indexOf(user, ",") - 1)
	, ['M', 'r', ' ', 'A','n', 'd', 'e', 'r','s', 'o', 'n'])
assert.group(".takeRight")
assert.label("default tests")
assert.test(_.takeRight([1, 2, 3]), [3])
assert.test(_.takeRight([1, 2, 3], 2), [2, 3])
assert.test(_.takeRight([1, 2, 3], 5), [1, 2, 3])
assert.test(_.takeRight([1, 2, 3], 0), [])
assert.test(_.takeRight("neo"), ["o"])
assert.test(_.takeRight(100), ["0"])
assert.test(_.takeRight([]), [])
assert.label("mutation")
str := "neo"
assert.test(_.takeRight(str, 3), ["n","e","o"])
assert.test(str, "neo")
obj := [1, 2, 3]
assert.test(_.takeRight(obj), [3])
assert.test(obj, [1, 2, 3])
assert.group(".union")
assert.label("default tests")
assert.test(_.union([2], [1, 2]), [2, 1])
assert.test(_.union([1, 2, 3], [4, 5], [6, 7], [8, 9], [2, 4, 6, 8]), [1, 2, 3, 4, 5, 6, 7, 8, 9])
assert.test(_.union(["Neo", "Barney", "morpheus", "morpheus"]), ["Neo", "Barney", "morpheus"])
assert.test(_.union("hello!"), ["hello!"])
assert.group(".uniq")
assert.label("default tests")
assert.test(_.uniq([2, 1, 2]), [2, 1])
assert.test(_.uniq(["Neo", "Barney", "morpheus", "morpheus"]), ["Neo", "Barney", "morpheus"])
arr := [70, 88, 12, 52, 27, 14, 86, 54, 24, 55, 29, 33, 33, 25, 99]
arr2 := _.uniq(arr)
assert.test(arr.length, 15)
assert.test(arr2.length, 14)
assert.test(_.uniq("9000"), ["9", "0"])
assert.group(".unzip")
assert.label("default tests")
zipped := _.zip(["a", "b"], [1, 2], [true, false])
assert.test(_.unzip(zipped), [["a", "b"], [1, 2], [true, false]])
assert.test(_.unzip([["a", 1, true], ["b", 2, false]]), [["a", "b"], [1, 2], [true, false]])
assert.test(_.unzip([["a", "b", "c"]]), [["a"], ["b"], ["c"]])
assert.test(_.unzip([["a", 1], ["b", 2, false]]), [["a", "b"], [1, 2]])
assert.test(_.unzip([["a", 1], []]), [["a"], [1]])
assert.test(_.zip(["a", "b"]), [["a"], ["b"]])
assert.test(_.zip(["a", "b"], [1]), [["a", 1]])
assert.group(".without")
assert.label("default tests")
assert.test(_.without([2, 1, 2, 3], 1, 2), [3])
assert.test(_.without([2, 1, 2, 3], 1), [2, 3])
assert.test(_.without([2, 1, 2, 3], 1, 2, 3), [])
assert.group(".zip")
assert.label("default tests")
assert.test(_.zip(["a", "b"], [1, 2], [true, true]),[["a", 1, true], ["b", 2, true]])
obj1 := ["one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten"]
obj2 := ["one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten"]
assert.test(_.zip(obj1, obj2),[["one", "one"], ["two", "two"], ["three", "three"], ["four", "four"], ["five", "five"], ["six", "six"], ["seven", "seven"], ["eight", "eight"], ["nine", "nine"], ["ten", "ten"]])
assert.group(".zipObject")
assert.label("default tests")
assert.test(_.zipObject(["a", "b"], [1, 2]), {a: 1, b: 2})
assert.label("uneven input arrays")
assert.test(_.zipObject(["a", "b", "c"], [1, 2]), {a: 1, b: 2, c: ""})
assert.group(".filter")
assert.label("default tests")
users := [{user: "barney", age: 36, active: true}, {user: "fred", age: 40, active: false}]
assert.test(_.filter(users, fn_filterFunc), [{user: "barney", age: 36, active: true}])
fn_filterFunc(param_iteratee) {
	if (param_iteratee.active) {
		return true
	}
}
assert.label("call own biga.ahk method (guarded)")
assert.test(_.filter([1, 20, 0, 40, 1], _.isBoolean), [1, 0, 1])
assert.label(".matches longhand")
assert.label("call own biga.ahk method (unguarded)")
assert.test(_.filter(users, _.isObject), users)
assert.label("using value")
assert.test(_.filter([1, 2, 3, -10, 1.9], fn_filter2), [2,3])
fn_filter2(param_iteratee) {
	if (param_iteratee >= 2) {
		return true
	}
}
assert.label("using value and key")
assert.test(_.filter([1, 2, 3, -10, 1.9, "even"], fn_filter3), [2, -10, "even"])
fn_filter3(param_iteratee, param_key) {
	if (mod(param_key, 2) = 0) {
		return true
	}
}
assert.label("using value, key, and collection")
assert.test(_.filter([1, 2, 3, -10, 1.9, "even"], fn_filter4), [2])
fn_filter4(param_iteratee, param_key, param_collection) {
	if (isNumber(param_iteratee)) {
		if (mod(param_key, 2) = 0 && _.indexOf(param_collection, param_iteratee / 2) != -1) {
			return true
		}
	}
}
assert.group(".includes")
assert.label("default tests")
assert.group(".map")
assert.label("default tests")
fn_square(n) {
	return n * n
}
assert.test(_.map([4, 8], fn_square), [16, 64])
assert.test(_.map({ a: 4, b: 8 }, fn_square), [16, 64])
data_array := ["Neo", "Morpheus", "Trinity"]
assert.test(_.map(data_array, (value) => ({name: value, id: A_Index})), [{name: "Neo", id: 1}, {name: "Morpheus", id: 2}, {name: "Trinity", id: 3}])
assert.label("object values")
assert.test(_.map({ a: 4, b: 8 }), [4, 8])
assert.label("MAP() values")
assert.label("string input")
assert.test(_.map("Neo"), ["N", "e", "o"])
assert.label("gaurded func input")
assert.test(_.map([" hello ", " world "], trim), ["hello", "world"])
assert.label(".random")
output := _.map([100, 10], _.random)
assert.true(_.isNumber(output[1]))
assert.true(_.isNumber(output[2]))
assert.true((output[1] <= 100))
assert.true((output[1] >= 0))
assert.true((output[2] <= 10))
assert.true((output[2] >= 0))
assert.label(".random floating point only")
output := _.map([true, true], _.random)
assert.true(_.isFloat(output[1]))
assert.true(_.isFloat(output[2]))
assert.true((output[1] <= 1))
assert.true((output[1] >= 0))
assert.true((output[2] <= 1))
assert.true((output[2] >= 0))
assert.label(".drop")
assert.test(_.map(["foo", "bar"], _.drop), [["o", "o"], ["a", "r"]])
assert.label(".trim")
assert.test(_.map([" 	 hello 	 ", "	 	world	 	"], _.trim), ["hello", "world"])
assert.label(".trimEnd")
assert.test(_.map([" hello 	 ", " world	 	"], _.trimEnd), [" hello", " world"])
assert.label(".trimStart")
assert.test(_.map([" 	 hello 	 ", "	 	world	 	"], _.trimStart), ["hello 	 ", "world	 	"])
assert.label(".parseInt")
assert.test(_.map(["08", "	09", "10.01"], _.parseInt), [8, 9, 10])
assert.label(".chunk")
assert.test(_.map("Neo", _.chunk), [[["N"]], [["e"]], [["o"]]])
assert.test(_.map(["Neo", "Morpheus", "Trinity"], _.chunk)
	, [[["N"], ["e"], ["o"]], [["M"], ["o"], ["r"], ["p"], ["h"], ["e"], ["u"], ["s"]], [["T"], ["r"], ["i"], ["n"], ["i"], ["t"], ["y"]]])
assert.label(".take")
assert.test(_.map("Neo", _.take), [["N"], ["e"],  ["o"]])
assert.test(_.map(["Neo", "Morpheus"], _.take), [['N'], ['M']])
assert.label(".takeRight")
assert.test(_.map("Neo", _.takeRight), [["N"], ["e"], ["o"]])
assert.test(_.map(["Neo", "Morpheus"], _.takeRight), [['o'], ['s']])
assert.label(".parseInt")
assert.test(_.map(["6", "08", "10"], _.parseInt), [6, 8, 10])
assert.label(".sample")
assert.true(_.isArray(_.map(["Neo", "Morpheus", "Trinity"], _.sample)))
assert.true(_.isArray(_.map([[1, 2, 3], [1, 2, 3], [1, 2, 3]], _.sample)))
assert.label(".words")
assert.true(_.isArray(_.map(["Neo", "Morpheus", "Trinity"], _.words)))
assert.test((_.map(["hello world", "foo bar", "hello, world"], _.words))
	, [["hello", "world"], ["foo", "bar"], ["hello", "world"]])
assert.group(".map, native functions")
assert.label("strLen, lowercase")
assert.test(_.map(["hello", " world "], strLen), [5, 7])
assert.label("rtrim")
assert.test(_.map([" hello ", " world "], rtrim), [" hello", " world"])
assert.label("ltrim")
assert.test(_.map([" hello ", " world "], ltrim), ["hello ", "world "])
userData := [" John Doe, 30 ", "Jane Smith,  25", "ALICE O'CONNOR,45"]
cleanedData := _.map(userData, myFunc)
myFunc(user) {
	name := _.trim(_.lowerFirst(_.join(_.take(user, _.indexOf(user, ",") - 1), "")))
	age := _.parseInt(strSplit(user, ",")[2])
	return {name: name, age: age}
}
assert.test(cleanedData, [{age:30, name:"John Doe"}, {age:25, name:"jane Smith"}, {age:45, name:"aLICE O'CONNOR"}])
assert.group(".sample")
assert.label("default tests")
assert.label("regular array")
output := _.sample([1, 2, 3])
assert.test(_.isNumber(output), 1)
assert.false(isObject(output))
assert.label("array of objects")
output := _.sample([{key: 1} , {key: 2}, {key: 3}])
assert.test(_.size(output), 1)
assert.true(isObject(output))
; assert.true(_.includes(output, "value"))
assert.label("string input")
output := _.sample("abc")
assert.true(_.includes(["a", "b", "c"], output))
assert.true(_.isString(output))
assert.label("empty input")
assert.test(_.size(_.sample([])), 0)
assert.undefined(_.sample([]))
assert.group(".shuffle")
assert.label("default tests")
shuffleTestVar := _.shuffle([1, 2, 3, 4])
assert.test(shuffleTestVar.length, 4)
shuffleTestVar := _.shuffle(["morpheus", "neo", "trinity"])
assert.test(shuffleTestVar.length, 3)
shuffleTestVar := _.shuffle([{key: 1}, {key: 1}, {key: 1}])
assert.test(shuffleTestVar.length, 3)
assert.test(shuffleTestVar[1], {key: 1})
assert.test(shuffleTestVar[2], {key: 1})
assert.test(shuffleTestVar[3], {key: 1})
assert.label("empty array")
assert.test(_.shuffle([]), [])
assert.label("sparse arrays")
shuffleTestVar := _.shuffle({2: 1, 4: 1, 6: 1})
shuffleTestVar := _.map(_.compact(shuffleTestVar))
assert.test(shuffleTestVar.length, 3)
assert.test(shuffleTestVar[1], 1)
assert.test(shuffleTestVar[2], 1)
assert.test(shuffleTestVar[3], 1)
shuffleTestVar := _.shuffle({2: 1, 600: 1})
shuffleTestVar := _.map(_.compact(shuffleTestVar))
assert.test(shuffleTestVar.length, 2)
assert.test(shuffleTestVar[1], 1)
assert.test(shuffleTestVar[2], 1)
assert.label("no mutation of input object")
arr := [1, 2, 3, 4, 5]
_.shuffle(arr)
assert.test(arr, [1, 2, 3, 4, 5])
assert.group(".size")
assert.label("default tests")
assert.test(_.size([1, 2, 3]), 3)
assert.test(_.size({ a: 1, b: 2 }), 2)
assert.test(_.size("trinity"), 7)
assert.label("empty array")
assert.test(_.size([]), 0)
assert.test(_.size({}), 0)
assert.label("objects")
users := [{user: "morpheus", active: true}
	, {user: "neo", active: false}
	, {user: "trinity", active: false}]
assert.test(_.size(users), 3)
assert.label("empty value")
assert.test(_.size(["A", "", "C"]), 3)
assert.label("blank value")
assert.test(_.size(["A", , "C"]), 3)
assert.label("empty string input")
assert.test(_.size(""), 0)
assert.label("map")
assert.test(_.size(map("a", 1, "b", 2)), 2)
class Mapi extends Map {
    CaseSense := false
}
assert.label("mapi")
myMapi := Mapi("a", 1, "b", 2, "c", 3)
assert.test(_.size(myMapi), 3)
assert.label("int input is always zero")
assert.test(_.size(1), 0)
assert.test(_.size(8), 0)
assert.test(_.size(9000), 0)
assert.label("float input is always zero")
assert.test(_.size(2.02), 0)
assert.test(_.size(0.00000000000001), 0)
assert.test(_.size(9000.1), 0)
assert.group(".some")
assert.label("default tests")
assert.true(_.some(["foo", "bar", 42], _.isNumber))
assert.true(_.some({key1: 10, key2: 20}, _.isNumber))
assert.group("._applyPredicate")
assert.label("default tests")
assert.test(_._applyPredicate([1,2,3], 0, 8, fn_square), 64)
assert.test(_._applyPredicate([], 0, " hello ", _.trim), "hello")
assert.group("._createShorthandFn")
assert.label("default tests")
users := [{user: "Neo", active: true},
	{user: "Morpheus", active: false}]
assert.true(_.isFunction(_._createShorthandFn({user: "Neo", active: true}, users)))
assert.test(type(_._createShorthandFn({user: "Neo", active: true}, users)), "BoundFunc")
assert.group("._findGuarded")
assert.label("default tests")
assert.group("._hash")
assert.label("default tests")
assert.group("._isFalsey")
assert.label("default tests")
assert.label("empty string")
assert.true(_._isFalsey(""))
assert.label("unset")
assert.true(_._isFalsey(unset))
assert.label("object")
assert.false(_._isFalsey({}))
assert.label("space string")
assert.false(_._isFalsey(" "))
assert.label("zero")
assert.true(_._isFalsey(0))
assert.label("false")
assert.true(_._isFalsey(false))
assert.group("._stringify")
assert.label("default tests")
assert.test(_._stringify({a: 1}), "{a: 1}")
assert.test(_._stringify({}), "{}")
assert.test(_._stringify(object()), "{}")
assert.test(_._stringify(object), "Class")
assert.test(_._stringify([]), "[]")
assert.test(_._stringify("string"), "'string'")
assert.test(_._stringify("string"), "'string'")
assert.group("._throwTypeException")
assert.label("default tests")
assert.group("._validateTypes")
assert.label("default tests")
myObj := {foo: 1, bar: 2}
_._validateTypes(myObj, ["object"])
assert.group(".clone")
assert.label("default tests")
objects := [{ a: 1 }, { b: 2 }]
shallow := _.clone(objects)
assert.true(_.isEqual(objects, shallow))
assert.equal(objects, shallow)
var := 33
cloned := _.clone(var)
cloned++
assert.notEqual(var, cloned)
assert.equal(_.cloneDeep(map(1, 20, 2, 40)), [1, 2])
assert.group(".cloneDeep")
assert.label("default tests")
obj := [{ a: [[1, 2, 3]] }, { b: 2 }]
deepclone := _.cloneDeep(obj)
obj[1].a := 2
assert.test(deepclone, [{ a: [[1, 2, 3]] }, { b: 2 }])
assert.test(obj, [{ a: 2 }, { b: 2 }])
assert.group(".isAlnum")
assert.label("default tests")
assert.false(_.isAlnum(1))
assert.true(_.isAlnum("hello"))
assert.false(_.isAlnum([]))
assert.false(_.isAlnum({}))
assert.true(_.isAlnum("08"))
assert.group(".isArray")
assert.label("default tests")
assert.true(_.isArray([1, 2, 3]))
assert.false(_.isArray("abc"))
assert.false(_.isArray({key: "value"}))
assert.false(_.isArray(1))
assert.false(_.isArray(""))
assert.group(".isBoolean")
assert.label("default tests")
assert.true(_.isBoolean(true))
assert.true(_.isBoolean(1))
assert.true(_.isBoolean(false))
assert.true(_.isBoolean(0))
assert.false(_.isBoolean(0.1))
assert.false(_.isBoolean(1.1))
assert.false(_.isBoolean("1.1"))
assert.false(_.isBoolean("false"))
assert.false(_.isBoolean("true"))
assert.group(".isBuffer")
assert.label("default tests")
myBuffer := buffer(20, 100)
assert.true(_.isBuffer(myBuffer))
assert.false(_.isBuffer([]))
assert.false(_.isBuffer({}))
assert.false(_.isBuffer(map()))
assert.false(_.isBuffer(1))
assert.false(_.isBuffer("two"))
assert.false(_.isBuffer(3.33))
assert.group(".isEmpty")
assert.label("default tests")
assert.label("Array")
assert.true(_.isEmpty([]))
assert.label("Object")
assert.true(_.isEmpty({}))
assert.label("Map")
assert.true(_.isEmpty(map()))
assert.label("empty string")
assert.false(_.isEmpty(""))
assert.label("unset")
; assert.false(_.isEmpty(unset))
assert.label("space string")
assert.false(_.isEmpty(" "))
assert.label("zero")
assert.false(_.isEmpty(0))
assert.label("false")
assert.false(_.isEmpty(false))
assert.group(".isEqual")
assert.label("default tests")
assert.true(_.isEqual(1, 1))
assert.true(_.isEqual({ a: 1 }, { a: 1 }))
assert.false(_.isEqual(1, 1, 2))
_.stringCaseSense := true
assert.false(_.isEqual({ a: "a" }, { a: "A" }))
_.stringCaseSense := false
assert.false(_.isEqual({ a: 1 }, { a: 2 }))
assert.label("variadric parameters")
assert.true(_.isEqual(1, 1, 1))
assert.true(_.isEqual({ a: 1 }, { a: 1 }, { a: 1 }))
assert.false(_.isEqual(1, 1, { a: 1 }))
assert.label("leading zeros")
assert.true(_.isEqual(00000000011, 11))
assert.true(_.isEqual(00011, 11))
assert.true(_.isEqual(011, 11))
assert.true(_.isEqual(11, 11))
assert.label("decimal places")
assert.true(_.isEqual(1.0, 1.000))
assert.true(_.isEqual(11, 11.000))
assert.false(_.isEqual(11, 11.0000000001))
assert.label("string comparison")
assert.true(_.isEqual(11, "11"))
assert.true(_.isEqual("11", "11"))
assert.label("empty object")
assert.true(_.isEqual({}, {}))
assert.label("different keys")
assert.false(_.isEqual({a: 1}, {b: 1}))
assert.false(_.isEqual({a: 1}, [1]))
assert.label("different lengths")
assert.false(_.isEqual({a: 1}, {a: 1, c: 2}))
assert.false(_.isEqual({a: 1, c: 2}, {a: 1}))
assert.group(".isFloat")
assert.label("default tests")
assert.true(_.isFloat(1.0))
assert.false(_.isFloat(1))
assert.group(".isFunction")
assert.label("default tests")
bndFunc := strLen.bind("one")
assert.true(_.isFunction(bndFunc))
assert.true(_.isFunction(_.size))
assert.false(_.isFunction([1, 2, 3]))
assert.false(_.isFunction([]))
assert.false(_.isFunction({}))
assert.false(_.isFunction(map()))
assert.false(_.isFunction(1))
assert.false(_.isFunction("two"))
assert.false(_.isFunction(3.33))
assert.true(_.isFunction(make_greeter("Hello, {}!"))) 
make_greeter(f)
{
    greet(subject) {
        Format(f, subject)
    }
    return greet
}
assert.group(".isInteger")
assert.label("default tests")
assert.true(_.isInteger(1))
assert.false(_.isInteger("1"))
assert.label("omit")
; assert.true(_.isInteger(1.0000))
assert.true(_.isInteger(-1))
assert.true(_.isInteger(-10))
assert.false(_.isInteger(1.00001))
assert.false(_.isInteger([]))
assert.false(_.isInteger({}))
assert.group(".isMap")
assert.label("default tests")
assert.label("empty string")
assert.true(_.isMap(map(1, "Neo")))
assert.label("array")
assert.false(_.isMap([]))
assert.label("object")
assert.false(_.isMap({}))
assert.label("space string")
assert.false(_.isMap(" "))
assert.label("zero")
assert.false(_.isMap(0))
assert.label("false")
assert.false(_.isMap(false))
assert.group(".isMatch")
assert.label("default tests")
obj := { a: 1, b: 2, c: 3 }
assert.true(_.isMatch(obj, {b: 2}))
assert.true(_.isMatch(obj, {b: 2, c: 3}))
assert.false(_.isMatch(obj, {b: 1}))
assert.false(_.isMatch(obj, {b: 2, z: 99}))
assert.group(".isNative")
assert.label("default tests")
assert.true(_.isNative(isFloat))
boundFn := inStr.bind()
assert.false(_.isNative(boundFn))
assert.false(_.isNative(_))
assert.group(".isNumber")
assert.label("default tests")
assert.true(_.isNumber(1))
assert.true(_.isNumber("1"))
assert.true(_.isNumber("1.001"))
assert.false(_.isNumber([]))
assert.false(_.isNumber({}))
assert.group(".isObject")
assert.label("default tests")
assert.true(_.isObject({}))
assert.true(_.isObject([1, 2, 3]))
assert.false(_.isObject(""))
assert.group(".isString")
assert.label("default tests")
assert.true(_.isString("abc"))
assert.false(_.isString(1))
assert.true(_.isString("1"))
assert.true(_.isString("."))
assert.false(_.isString(1.0000))
assert.false(_.isString(1.0001))
assert.true(_.isString("1.0000"))
assert.false(_.isString({}))
assert.group(".isUndefined")
assert.label("default tests")
assert.false(_.isUndefined(""))
assert.false(_.isUndefined({}))
assert.false(_.isUndefined(" "))
assert.false(_.isUndefined(0))
assert.false(_.isUndefined(false))
assert.group(".toString")
assert.label("default tests")
assert.group(".typeOf")
assert.label("default tests")
assert.test(_.typeOf(42), "integer")
assert.test(_.typeOf(0.25), "float")
assert.test(_.typeOf("0.25"), "string")
assert.test(_.typeOf("blubber"), "string")
assert.test(_.typeOf([]), "array")
assert.test(_.typeOf({}), "object")
assert.test(_.typeOf(map()), "map")
assert.test(_.typeOf(object), "class")
assert.test(_.typeOf(_), "class")
assert.test(_.typeOf(adash), "class")
assert.group(".add")
assert.label("default tests")
assert.test(_.add(6, 4), 10)
assert.test(_.add(10, -1), 9)
assert.test(_.add(-10, -10), -20)
assert.test(_.add(10, 0.01), 10.01)
assert.label("parameter mutation")
value := 10
_.add(value, 10)
assert.test(value, 10)
assert.group(".ceil")
assert.label("default tests")
assert.test(_.ceil(4.006), 5)
assert.test(_.ceil(6.004, 2), 6.01)
assert.test(_.ceil(6040, -2), 6100)
assert.test(_.ceil(4.1), 5)
assert.test(_.ceil(4.5), 5)
assert.test(_.ceil(41), 41)
assert.test(_.ceil(6.004, 2), 6.01)
assert.test(_.ceil(6.004, 1), 6.1)
assert.test(_.ceil(6040, -3), 7000)
; assert.test(_.ceil(2.22, 2), 2.22)
assert.test(_.ceil(-2.22000000000000020, 2), -2.22)
assert.label("Ceiling with exact match at second decimal")
; assert.test(_.ceil(2.2200000000000002, 2), "2.22") ; âœ…
assert.label("Ceiling with rounding up at second decimal")
assert.test(_.ceil(2.2200000002, 2), "2.23") ; âœ…
assert.group(".divide")
assert.label("default tests")
assert.test(_.divide(6, 4), 1.5)
assert.test(_.divide(10, -1), -10)
assert.test(_.divide(-10, -10), 1)
assert.test(_.divide(0, 5), 0)
assert.test(_.divide(10, 0), "")
assert.group(".floor")
assert.label("default tests")
assert.test(_.floor(4.006), 4)
assert.test(_.floor(0.046, 2), 0.04)
assert.test(_.floor(4060, -2), 4000)
assert.test(_.floor(4.1), 4)
assert.test(_.floor(4.6), 4)
assert.test(_.floor(41), 41)
assert.test(_.floor(45), 45)
assert.test(_.floor(6.004, 2), 6.00)
assert.test(_.floor(6.004, 1), 6.0)
assert.test(_.floor(6040, -3), 6000)
assert.test(_.floor(2.22, 1), 2.2)
assert.test(_.floor(-2.22000000000000020, 2), -2.22)
assert.test(_.floor(2.22000000000000020, 2), 2.22)
assert.test(_.floor(4.999), 4)
assert.group(".max")
assert.label("default tests")
assert.test(_.max([4, 2, 8, 6]), 8)
assert.test(_.max([]), "")
assert.test(_.max([-10, -20, -5]), -5)
assert.label("associative array")
assert.group(".mean")
assert.label("default tests")
assert.test(_.mean([4, 2, 8, 6]), 5)
assert.label("same value")
assert.test(_.mean([10, 10, 10]), 10)
assert.label("with string value")
assert.test(_.mean([10, "10", 10]), 10)
assert.label("decimals")
assert.test(_.mean([10.1, 42.9]), 26.5)
assert.label("empty values")
assert.test(_.mean([4, 2, , 8, 6]), 4)
assert.label("empty values")
assert.test(_.mean([4, 2, , 3, 6, unset]), 2.5)
assert.group(".min")
assert.label("default tests")
assert.test(_.min([4, 2, 8, 6]), 2)
assert.test(_.min([]), "")
assert.label("negative numbers")
assert.test(_.min([-100, -50, 0, 10]), -100)
assert.label("empty and unset values")
assert.test(_.min(["", , , 10]), 10)
assert.label("all empty and unset values")
assert.test(_.min(["", , , ""]), "")
assert.group(".multiply")
assert.label("default tests")
assert.test(_.multiply(6, 4), 24)
assert.label("negative numbers")
assert.test(_.multiply(10, -1), -10)
assert.test(_.multiply(-10, -10), 100)
assert.group(".round")
assert.label("default tests")
assert.label("without precision")
assert.test(_.round(4.006), 4)
assert.label("with precision")
assert.test(_.round(4.006, 2), 4.01)
assert.test(_.round(4060, -2), 4100)
assert.group(".subtract")
assert.label("default tests")
assert.test(_.subtract(6, 4), 2)
assert.label("negtive number")
assert.test(_.subtract(10, -1), 11)
assert.test(_.subtract(-10, -10), 0)
assert.test(_.subtract(-6, -4), -2)
assert.label("decimal")
assert.test(_.subtract(10, 0.01), 9.99)
assert.label("parameter mutation")
g_value := 10
assert.test(_.subtract(g_value, 10), 0)
assert.test(g_value, 10)
assert.group(".sum")
assert.label("default tests")
assert.test(_.sum([4, 2, 8, 6]), 20)
assert.label("associative array")
; assert.test(_.sum({key1: 4, key2: 6}), 10)
assert.label("negtive number")
assert.test(_.sum([-4, 2, -8, 6]), -4)
assert.label("negtive number")
assert.test(_.sum([-4, 2, -8, 6]), -4)
assert.label("empty objects")
assert.test(_.sum([]), -0)
assert.test(_.sum({key: 1, key2: 10}), 0)
assert.group(".clamp")
assert.label("default tests")
assert.test(_.clamp(-10, -5, 5), -5)
assert.test(_.clamp(10, -5, 5), 5)
; ensure no change to params
var := -10
assert.test(_.clamp(var, -5, 5), -5)
assert.test(var, -10)
assert.label("parameter mutation")
value := 10
_.clamp(value, -5, 5)
assert.test(value, 10)
assert.group(".inRange")
assert.label("default tests")
assert.true(_.inRange(3, 2, 4))
assert.true(_.inRange(4, 8))
assert.false(_.inRange(4, 2))
assert.false(_.inRange(2, 2))
assert.true(_.inRange(1.2, 2))
assert.false(_.inRange(5.2, 4))
assert.true(_.inRange(-3, -2, -6))
assert.true(_.inRange(2, 2, 4))
assert.false(_.inRange(4, 2, 4))
assert.group(".random")
assert.label("default tests")
output := _.random(0, 1)
assert.true(_.isNumber(output))
assert.label("floating point is returned")
assert.true(_.isFloat(_.random(0, 1, true)))
assert.true((_.random(0, 1, true) < 1.00))
assert.label("floating point is returned on ``true`` input")
assert.true(_.isFloat(_.random(true)))
assert.true((_.random(true) < 1.00))
assert.group(".get")
assert.label("default tests")
obj := {a: [{b: {c: 3}}]}
assert.test(_.get(obj, "a[1].b.c"), 3)
assert.test(_.get(obj, ["a", "1", "b", "c"]), 3)
assert.test(_.get(obj, "a.b.c", "default"), "default")
assert.test(_.get(obj, "a[0]"), [{ b: {c: 3} }])
assert.test(_.get(obj, "a[1]"), { b: {c: 3} })
assert.group(".set")
assert.label("default tests")
obj := {a: [{b: {c: 3}}]}
_.set(obj, "a[1].b.c", 4)
assert.test(obj.a[1].b.c, 4)
_.set(obj, ["x", "1", "y", "z"], 5)
assert.test(obj.x[1].y.z, 5)
obj := {a: [{b: {c: 3}}]}
assert.test(_.set(obj, "a", []), {a: []})
obj := {a: [{b: {c: 3}}]}
_.set(obj, "a[1].b.d", 5)
assert.test(_.get(obj, "a[1].b.d"), 5, "add new key to existing object")
obj := {}
_.set(obj, "a[1]", 1)
assert.test(obj, {a: [1]}, "set array index 1")
obj := {}
_.set(obj, "a[2].b", 2)
assert.test(obj, {a: [{}, {b: 2}]}, "set nested array with index 2")
obj := {a: [{b: {c: 3}}]}
_.set(obj, "a[1].b.c", 4)
assert.test(_.get(obj, "a[1].b.c"), 4, "modify existing value")
obj := {}
_.set(obj, "x[1].y.z", 5)
assert.test(_.get(obj, "x[1].y.z"), 5, "create nested path with array index and set value")
obj := {}
_.set(obj, ["x", "1", "y", "z"], 5)
assert.test(_.get(obj, ["x", "1", "y", "z"]), 5, "set value with array path input")
obj := {}
_.set(obj, "a.b.c.d.e", 10)
assert.test(_.get(obj, "a.b.c.d.e"), 10, "deep nested path creation")
obj := {a: {b: {c: {d: {e: 10}}}}}
_.set(obj, "a.b.c.d.e", 20)
assert.test(_.get(obj, "a.b.c.d.e"), 20, "modify deep nested value")
obj := {}
_.set(obj, "a[0].b.c[1].d", 30)
assert.test(_.get(obj, "a[0].b.c[1].d"), 30, "complex nested path with arrays")
assert.group(".endsWith")
assert.label("default tests")
assert.true(_.endsWith("abc", "c"))
assert.false(_.endsWith("abc", "b"))
assert.true(_.endsWith("abc", "b", 2))
assert.label("ahk `; comment detection")
assert.true(_.endsWith("String;", ";"))
assert.true(_.endsWith("String;", "ing;"))
assert.true(_.endsWith("String;", "String;"))
assert.label("fromIndex")
assert.true(_.endsWith("String;", "g", 6))
assert.group(".escape")
assert.label("default tests")
str := "neo, morpheus, & trinity"
assert.test(_.escape(str), "neo, morpheus, &amp; trinity")
assert.test(_.escape("&&&"), "&amp;&amp;&amp;")
assert.group(".lowerFirst")
assert.label("default tests")
assert.test(_.lowerFirst("Neo"), "neo")
assert.test(_.lowerFirst("FRED"), "fRED")
assert.test(_.lowerFirst("--foo-bar--"), "--foo-bar--")
assert.test(_.lowerFirst("fooBar"), "fooBar")
assert.test(_.lowerFirst("__FOO_BAR__"), "__FOO_BAR__")
assert.group(".pad")
assert.label("default tests")
assert.test(_.pad("abc", 8), "  abc   ")
assert.test(_.pad("abc", 8, "_-"), "_-abc_-_")
assert.test(_.pad("abc", 3), "abc")
assert.test(_.pad("abc", 4), "abc ")
assert.test(_.pad("abc", 9), "   abc   ")
assert.group(".padEnd")
assert.label("default tests")
assert.test(_.padEnd("abc", 6), "abc   ")
assert.test(_.padEnd("abc", 6, "_-"), "abc_-_")
assert.test(_.padEnd("abc", 3), "abc")
assert.test(_.padEnd("abc", 8, "123"), "abc12312")
assert.test(_.padEnd("", 5, "x"), "xxxxx")
assert.group(".padStart")
assert.label("default tests")
assert.test(_.padStart("abc", 6), "   abc")
assert.test(_.padStart("abc", 6, "_-"), "_-_abc")
assert.test(_.padStart("abc", 3), "abc")
assert.test(_.padStart("abc", 8, "123"), "12312abc")
assert.test(_.padStart("", 5, "x"), "xxxxx")
assert.group(".parseInt")
assert.label("default tests")
assert.test(_.parseInt("08"), 8)
assert.test(_.map(["6", "08", "10"], _.parseInt), [6, 8, 10])
assert.test(_.parseInt("0"), 0)
assert.test(_.parseInt(" 0"), 0)
assert.test(_.parseInt("	200"), 200)
assert.test(_.parseInt(" 200"), 200)
assert.label("decimal places")
assert.test(_.parseInt("1.0"), 1)
assert.test(_.parseInt("1.0001"), 1)
assert.label("with leading space")
assert.test(_.parseInt(" 10"), 10)
assert.label("with comma")
assert.test(_.parseInt("10,00"), 10)
assert.label("with space")
assert.test(_.parseInt("10 00"), 10)
assert.label("with special character")
assert.test(_.parseInt("10+10"), 10)
assert.label("with periods")
assert.test(_.parseInt("9.000.000"), 9)
assert.label("invalid input")
assert.test(_.parseInt(" "), "")
assert.label("Radix 16")
assert.test(_.parseInt("FF", 16), 255)
assert.label("Radix 2 (binary)")
assert.test(_.parseInt(101010, 2), 42)
assert.label("Radix 16")
assert.test(_.parseInt("0xFF", 16), 255)
assert.label("Radix 2")
assert.test(_.parseInt("0b101010", 2), 0)
assert.label("Radix 10")
assert.test(_.parseInt("0d42", 10), 0)
assert.group(".repeat")
assert.label("default tests")
assert.test(_.repeat("*", 3), "***")
assert.test(_.repeat("abc", 2), "abcabc")
assert.test(_.repeat("abc", 0), "")
assert.label("negative parameter")
assert.test(_.repeat("abc", -1), "")
assert.label("float input")
assert.label("integer input")
assert.test(_.repeat(2, 3), "222")
assert.group(".startsWith")
assert.label("default tests")
assert.true(_.startsWith("abc", "a"))
assert.false(_.startsWith("abc", "b"))
assert.true(_.startsWith("abc", "b", 2))
_.stringCaseSense := true
assert.false(_.startsWith("abc", "A"))
_.stringCaseSense := false
assert.true(_.startsWith("; String", ";"))
assert.true(_.startsWith("; String", "; "))
assert.true(_.startsWith("; String", "; String"))
assert.group(".toLower")
assert.label("default tests")
assert.test(_.toLower("--Foo-Bar--"), "--foo-bar--")
assert.test(_.toLower("fooBar"), "foobar")
assert.test(_.toLower("__FOO_BAR__"), "__foo_bar__")
assert.group(".toUpper")
assert.label("default tests")
assert.test(_.toUpper("--foo-bar--"), "--FOO-BAR--")
assert.test(_.toUpper("fooBar"), "FOOBAR")
assert.test(_.toUpper("__foo_bar__"), "__FOO_BAR__")
assert.group(".trim")
assert.label("default tests")
assert.test(_.trim("  abc  "), "abc")
assert.test(_.trim("-_-abc-_-", "_-"), "abc")
assert.test(_.map([" foo  ", "  bar  "], _.trim), ["foo", "bar"])
assert.label("multiple types of whitespace")
assert.test(_.trim(A_space A_tab "  abc  " A_tab), "abc")
assert.label("multiple types of newline")
assert.test(_.trim("  `rabc`n  "), "abc")
assert.group(".trimEnd")
assert.label("default tests")
assert.test(_.trimEnd("  abc  "), "  abc")
assert.test(_.trimEnd("-_-abc-_-", "_-"), "-_-abc")
assert.test(_.trimEnd("filename.txt", ".txt"), "filename")
assert.test(_.trimEnd("1000.00", "0"), "1000.")
assert.test(_.trimEnd("abcdefg", "gfedcba"), "")
assert.test(_.trimEnd("", "abc"), "")
assert.group(".trimStart")
assert.label("default tests")
assert.test(_.trimStart("  abc  "), "abc  ")
assert.test(_.trimStart("-_-abc-_-", "_-"), "abc-_-")
assert.group(".truncate")
assert.label("default tests")
str := "hi-diddly-ho there, neighborino"
assert.test(_.truncate(str), "hi-diddly-ho there, neighbor...")
assert.test(_.truncate(str, {length: 24, separator: " "}), "hi-diddly-ho there,...")
str := "the quick red fox jumped into something"
assert.test(_.truncate(str, {length: _.size(str) - 1, omission: ""}), "the quick red fox jumped into somethin")
assert.group(".unescape")
assert.label("default tests")
str := "neo, morpheus, &amp; trinity"
assert.test(_.unescape(str), "neo, morpheus, & trinity")
assert.test(_.unescape("&amp;&amp;&amp;"), "&&&")
assert.group(".upperFirst")
assert.label("default tests")
assert.test(_.upperFirst("neo"), "Neo")
assert.test(_.upperFirst("FRED"), "FRED")
assert.test(_.upperFirst("--foo-bar--"), "--foo-bar--")
assert.test(_.upperFirst("fooBar"), "FooBar")
assert.test(_.upperFirst("__FOO_BAR__"), "__FOO_BAR__")
assert.group(".words")
assert.label("default tests")
assert.test(_.words("neo, morpheus, & trinity"), ["neo", "morpheus", "trinity"])
assert.test(_.words("neo, morpheus, & trinity", "[^, ]+"), ["neo", "morpheus", "&", "trinity"])
assert.test(_.words("One, and a two, and a one two three"), ["One", "and", "a", "two", "and", "a", "one", "two", "three"])
assert.label("apostrophes")
assert.test(_.words("it's I'd ok. ok' k'o."), ["it's", "I'd", "ok", "ok", "k'o"])
assert.group(".constant")
assert.label("default tests")
obj := _.times(2, _.constant({a: 1}))
; => [{a: 1}, {a: 1}]
assert.test(obj, [{a: 1}, {a: 1}])
functor := _.constant({ a: 1 })
assert.test(functor.call({ a: 1 }), {a: 1})
assert.label("string")
obj := _.times(2, _.constant("string"))
assert.test(obj, ["string", "string"])
assert.group(".identity")
assert.label("default tests")
obj := {a: 1}
assert.test(_.identity(obj), {a: 1})
assert.true((_.identity(obj) == obj))
assert.group(".matches")
assert.label("default tests")
objects := [{ a: 1, b: 2, c: 3 }, { a: 4, b: 5, c: 6 }]
assert.test(_.filter(objects, _.matches({ a: 4, c: 6 })), [{ a: 4, b: 5, c: 6 }])
functor := _.matches({ a: 4 })
assert.test(_.filter(objects, functor), [{ a: 4, b: 5, c: 6 }])
assert.false(functor.call({ a: 1 }))
assert.group(".times")
assert.label("default tests")
assert.test(_.times(4), [1, 2, 3, 4])

assert.label("default .identity argument")
assert.test(_.times(2), [1, 2])
assert.test(_.times(2, _.trim), ["1", "2"])
assert.test(_.times(2, trim), ["1", "2"])
assert.group(".toPath")
assert.label("default tests")
assert.test(_.toPath("a.b.c"), ["a", "b", "c"])
assert.test(_.toPath("a[1].b.c"), ["a", "1", "b", "c"])
assert.test(_.toPath("a"), ["a"])
assert.test(_.toPath(["a", "1", "b", "c"]), ["a", "1", "b", "c"])
assert.test(_.toPath(["a", "1", "b", "", "c"]), ["a", "1", "b", "", "c"])
